<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style type="text/css">
    body {
      background-color: black;
    }

    canvas {
      background-color: white;
    }
  </style>
</head>

<body>
  <img src="assets/img/newTileset.png" style="display: none" id="tileset">
  <canvas id="canvas" width="900" height="600"></canvas>
  <script>
    const image = document.getElementById("tileset");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const random = (min = 0, max = 1, int = true) => {
      return (int) ?
        Math.floor(Math.random() * (max - min + 1)) + min :
        Math.random() * (max - min) + min;
    }

    const tileSize = 64;
    const animDuration = 3000;
    const animGoDuration = 15000;
    const gravity = 0.5;

    class Hero {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 64;
        this.imageData = [image, 3 * tileSize, 0, tileSize, tileSize];
      }
    }

    class Heart {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.size = 10;
        this.imageData = [image, 5 * tileSize, 1 * tileSize, tileSize, tileSize];
      }
    }

    let hero = new Hero(canvas.width / 2, canvas.height / 2);
    let hearts = new Array(10).fill(null).map(elem => new Heart(
      hero.x,
      hero.y,
      random(-1, 3),
      random(-10, 0)
    ));

    let start = null;

    const heartFontain = (timestamp) => {
      if (!start) { start = timestamp; }

      const elapsed = timestamp - start;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      //Hero
      ctx.save();
      ctx.globalAlpha = (1 - elapsed / animDuration);
      ctx.drawImage(...hero.imageData, hero.x - hero.size / 2, hero.y - hero.size / 2, hero.size, hero.size);
      ctx.restore();

      //Hearts
      for (let heart of hearts) {
        ctx.drawImage(...heart.imageData, heart.x - heart.size / 2, heart.y - heart.size / 2, heart.size, heart.size);

        heart.vy += gravity;
        heart.x += heart.vx;
        heart.y += heart.vy;

        //If heart touch limits reset to initial position
        if (heart.x - heart.size > hero.x + tileSize ||
          heart.x + heart.size < hero.x - tileSize ||
          heart.y - heart.size > hero.y + tileSize ||
          heart.y + heart.size < hero.y - tileSize) {
          heart.x = hero.x;
          heart.y = hero.y;
          heart.vx = random(-1, 3);
          heart.vy = random(-10, 0);
        }
      }

      if (elapsed >= animDuration) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        console.log("Go to game over");
        requestAnimationFrame(gameover);
      }
      else {
        requestAnimationFrame(heartFontain);
      }
    }

    let goStart = null;
    let canvasWindowRatio = canvas.width / window.innerWidth;
    let maxTxtSize = 0;

    const gameover = (timestamp) => {
      if (!goStart) { goStart = timestamp; }

      const elapsed = timestamp - goStart;

      //black screen
      ctx.save();
      ctx.fillStyle = "black";
      ctx.globalAlpha = elapsed / animGoDuration;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      //text
      ctx.save();
      const currTxtSize = elapsed / animGoDuration * 100;

      ctx.fillStyle = "white";
      ctx.font = `${elapsed / animGoDuration * 100}vw Sans serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const txtWidth = ctx.measureText("GAME OVER").width;

      if (txtWidth > canvas.width) {
        ctx.font = `${maxTxtSize}vw Sans serif`;
      }
      else {
        maxTxtSize = currTxtSize;
      }

      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2, canvas.width);
      ctx.restore();

      if (elapsed > animGoDuration) {
        console.log("Game over finished");
        return;
      }
      else {
        requestAnimationFrame(gameover);
      }
    }

    requestAnimationFrame(heartFontain);
  </script>
</body>

</html>